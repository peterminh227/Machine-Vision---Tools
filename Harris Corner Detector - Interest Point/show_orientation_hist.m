function show_orientation_hist(ori_hist, patch)
% SHOW_ORIENTATION_HIST show the orientations of an orientation histogram
% Can also show multiple orientation histograms, e.g. those generated by
% the orientation_block descriptor. Assumes that the histograms have 8 bins
% 
% ori_hist: orientation histogram vector, assumed to be divisible by 8
% patch: patch onto which to overlay the display. Assumed to be 16x16

per_line = 4;
% assume 8 bins
hist_bins = 8;

% assume given vector is evenly divisible by hist_bins
n_hists = numel(ori_hist)/hist_bins;

if nargin == 2
    [x, y] = meshgrid(2.5:4:16, 2.5:4:16);
    base_vecs = [y(:) x(:)];
else
    [x, y] = meshgrid(0:-1:-per_line-1, 0:max(1, floor(n_hists/per_line) - 1));
    base_vecs = [y(:) x(:)]*2;
end

% base vectors for the start point of each arrow. Each set of arrows will
% be plotted at a base location on a grid.

% Meshgrid generates more locations than needed, so we prune some of them.
base_vecs = base_vecs(1:n_hists, :);
% duplicate each row so that it is repeated hist_bins times - should be the
% same size as vecs.
base_vecs = kron(base_vecs, ones(hist_bins,1));

% these will be rotated according to the angles of bins
vecs = [ones(hist_bins*n_hists, 1) zeros(hist_bins*n_hists,1)];
vec_num = 1;
for h=1:n_hists
    angles = -pi:2*pi/hist_bins:pi;

    for i=1:size(angles,2)-1
        % generate rotation matrix around z axis and rotate one of the
        % basic vectors accordingly, weighting it by the value in the
        % histogram
        a = angles(i);
        R = [cos(a) -sin(a); sin(a) cos(a)];
        vecs(vec_num, :) = ori_hist((h-1)*hist_bins+i)*R*vecs(vec_num,:)';
        vec_num = vec_num + 1;
    end

end

if nargin == 2
    imshow(patch,[])
    hold on
end
quiver(base_vecs(:,1), base_vecs(:,2), vecs(:,1), vecs(:,2))